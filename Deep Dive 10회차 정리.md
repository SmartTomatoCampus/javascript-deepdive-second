# 함수2

## 김명성
자바스크립트는 멀티 패러다임 언어이므로 객체지향프로그래밍 뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.

함수는 한가지 일만 해야 하며 가급적 작게 만들어야 한다.
객체를 인수로 사용하는 경우 프로퍼터 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 된다.


반환문 return
함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.
함수는 return 키워드로 모든 값을 반환할 수 있다.
반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나가는 역할과 return 키워드 뒤에 오는 표현식을 평가해 반환한다.
return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
반환문은 생략할 수 있으며, 함수의 마지막 문까지 실행 후 암묵적으로 undefined를 반환한다.

객체의 방어적 복사
객체의 상태 변경이 필요한 경우 객체의 방어적 복사를 통해 원본 객체를 완전히 복제하는 깊은 복사를 통해
새로운 객체를 생성하고 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨 수 있다.

순수함수
외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다.
외부 상태에 의존하지 않고 함수 내부 상태에만 의존한다 해도 그 내부 상태가 호출될 때마다 변화하는 값(ex: current time)이라면 순수 함수가 아니다.
순수 함수는 일반적으로 하나 이상의 인수를 전달받는다.
그리고 순수 함수는 인수를 변경하지 않는 것이 기본이다.
다시 말해 순수 함수는 인수의 불변성을 유지한다.

비순수함수
인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조하면 외부 상태에 의존하게 되어
반환값이 변할 수 있고 외부 상태에도 변경할 수 있으므로 비순수 함수가 된다.
비순수 함수의 예시

> let updateValue;
> let updateCurrentIdx;
> function changeTodoTitle(e) {
>   const {value} = e.target // value == todo.id
>   updateValue = value
>   updateCurrentIdx = todos.findIndex(todo => todo.id === value)
>   onToggleUpdateInput(true)
> };

중첩함수
함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다.
중첩 함수를 포함하고 있는 함수를 외부 함수라 부른다.
중첩 함수는 외부 함수 내부에서만 호출할 수 있다.
일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 핼퍼 함수의 역할을 한다.

콜백함수
함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화하여 함수 외부에서 함수 내부로 전달하는 것이 콜백함수다.

콜백함수와 고차함수(HOF)
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.
고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.


## 초생
### 참조에 의한 전달과 외부 상태의 변경

원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다.

매개 변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또는 타입에 따라 값에 의한 전달을 그대로 따른다.

### 원시타입 인수

원시타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 값을 변경하더라도 원본이 훼손되지 않는다.

### 객체 타입 인수

객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.

함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 코드의 복잡성을 증가시키고 가독성을 해친다.

이러한 문제의 해결 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.

객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우는 방어적 복사를 통해 원본 객체를 완전히 복제, 깊은 복사를 통해 객체를 생성하고 재할당을 통해 교체한다.

## 쑥스럽게
9. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야한다.(매개변수0개가 가장 이상적 3개이상 넘지않을것을 권장)
10. return뒤엔 자동으로 세미콜론이 삽입된다 (줄을 이동하고싶으면 소괄호사용)
11. 함수의 매개변수로 들어온 인수가 원시값일때는 원본이 훼손되지 않지만 객체값이면 훼손 될 수 있다.
12. 즉시실행함수 : 함수 정의와 동시에 즉시 호출 되는 함수. 단 한번만 사용가능
  - (function (){
    ...code
    }())  ///이런형식임()소괄호로 싸야됨, 일반적으로 익명함수사용
13. 재귀함수 : 자기 자신을 호출하는 함수. 반복되는 처리를 반복문 없이 구현가능
  - 재귀함수는 자신을 무한 재귀 호출한다. 그러므로 무조건 탈출조건을 만들어야함
14. 중첩함수(내부함수) : 함수내부에 정의된 함수. 감싸고 있는 외부함수 내부에서만 호출가능.
15. 콜백함수 :
function 재귀(n){
  if(n<0) return;
   console.log(n);
   재귀(n - 1);
 }
// 재귀(10) // 10~0까지 순서대로 출력

## 클로버
매개변수는 적을수록 좋으며 이상적인 함수는 최대한 한가지 기능만 수행하는 것이 좋다.
매개변수가 많은 경우에는 객체를 선언해 인수로 전달하는 것이 좋다. 이 경우에는 사용시 매개변수의 순서도 상관없고 인수의 의미를 설명하는 프로퍼티 키를 사용하기 때문에 코드의 가독성도 좋아진다.
하지만 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경할 시 함수 외부의 객체도 변경되는 부수 효과가 있어 주의해야 한다.

매개변수도 인수의 타입에 따라서 값이 전달된다.

원시 타입 인수을 매개변수로 전달할때는 원시 값은 변경 불가능한 값이라 재할당을 통해 새로운 원시값을 복사해 매개변수로 전달하는데, 객체 타입 인수는 변경 가능한 값이라 재할당을 따로 하지 않는다. 또한 참조값을 공유하기 때문에 함수 내부에서 객체의 값을 변경하면 원본의 객체의 값이 변경된다.

이런 문제점을 해결하기 위해 옵저버 패턴틀 사용하거나 객체를 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 '불변 객체'로 만들어 사용하는 것이다. 재사용의 경우 깊은 복사를 통해 새로운 객체를 생성해 재할당하여 사용하는 것이 바람직하다. 비용은 더 들지만 부수효과를 막을 수 있기 때문이다.
즉시 실행 함수는 함수의 정의와 동시에 즉시 실행되며, 한 번만 호출 할 수 있는 함수이다.
반드시 그룹연산자()안에 써야하며 그룹연산자 안에는 값이 와야한다. 때문에 값으로 표현되는 함수 표현식으로 작동하기 때문에 익명함수를 일반적으로 사용한다.


콜백함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라 하며, 이와 반대로 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수를 고차 함수라 한다. 중첩 함수처럼 콜백함수는 기존의 함수를 도와주는 역활을 하는데 다른점은 중첩함수는 고정되어 있어 변경이 쉽지 않지만 콜백함수는 수정을 통해 유동적으로 사용할 수 있는 장점이 있다.

콜백함수는 고차함수에 상속되어있는 개념이라 호출시도 고차함수에 의해 정해지고 인수 또한 마찬가지로 고차함수에 의해 전달되어 진다.

순수 함수와 비순수 함수
부수효과가 없는 함수를 순수 함수라 하고 부수효과가 있는 함수를 비순수 함수라 한다.

