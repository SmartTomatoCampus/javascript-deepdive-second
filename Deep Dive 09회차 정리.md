# 함수

## 김명성
> 함수란?
프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
함수 내부로 입력을 전달받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라 한다.
자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당한다.
함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
그러나 함수 표현식으로 정의한 함수는 표현식 이전에 호출할 수 없다.
함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 함수 호이스팅이라 한다.
변수 호이스팅과 함수 호이스팅은 차이가 있다.
var 키워드로 선언한 변수 선언문과 함수 선언문은 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서는 동일하나, var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문은 함수 객체로 초기화된다.
함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.
함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다. 그렇기 때문에 함수 표현식을 사용할 것을 권장한다.
(하지만 호이스팅을 잘 사용하면 개꿀인 경우가 있다)
화살표 함수는 기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.
()
소괄호는 함수 호출 연산자이다.
인수는 값으로 평가될 수 있는 표현식이어야 한다
default parameter는 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효하다.

## 쑥스럽게
## 함수
1. 함수란? 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
2. 함수는 객체타입의 값이다. 하지만 일반 객체와 다르게 호출이 가능하고, 고유한 프로퍼티를 갖는다.
3. Function 생성자 함수
  var add = new Function('x','y','return x + y'); 
  // function 생성자함수. 밑에 함수선언문과 같은의미 
  function add(x,y){
    return x+y;
  }
4. {}는 블록문 또는 객체리터럴일 수도 있는 중의적표현이라 문맥에 따라 해석이 달라진다.
  - 단독으로 존재할때 -> 블록문
  - 값으로 평가되어야 할문맥(할당연산자의 우변 등..)에서 피연산자로 사용될때 ->객체리터럴

## 클로버
함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
함수는 함수 정의를 통해 생성되며 함수 호출시에 함수가 실행된다.

함수를 사용하는 이유는 실행 시점을 개발자가 결정할 수 있고 코드를 재사용하기에 편리하며 유지보수의 편의성이 높고 코드의 신뢰성이 높아진다.

또한 함수는 객체 타입의 값이며 식별자를 붙일 수 있는데 함수의 이름을 역할과 연관지어 짓는다면 코드를 읽지 않더라도 어떤 기능이 있는지 유추 가능하다. 따라서 코드의 가독성또한 향상시킨다.

함수의 이름과 매개변수는 식별자 네이밍 규칙을 준수해야한다.

함수 정의 방식에는 함수 선언문, 함수 표현식, function 생성자 함수, 화살표 함수(ES6)가 있다.

함수 선언문

함수 선언문은 함수 리터럴과 형태가 동일하다. 하지만 함수 선언문은 함수 이름을 생략할 수 없다.
리터럴과 익명함수와 함수선언문으로 만든 함수의 구체적인 차이점. 

함수 선언문은 표현식이 아닌 문이다. 함수 선언문을 콘솔에 찍어보면 완료값 undefined가 출력된다.
따라서 표현식이 아닌 문은 값이 없으므로 변수에 할당하지 못하는 것이 맞으나 함수의 경우 객체 리터럴과 함수선언문의 형태가 동일하기 때문에 중의적으로 해석되는 경우가 있다. 즉 코드 문맥에 따라 함수 선언문과 함수 리터럴로 선택되어 작동한다.

함수 선언문과 함수 리터럴은 모두 함수를 생성한다는 점에서 동일하지만 약간의 차이가 있다.
 ( function a(){ console.log('hi'); } );
 a(); // ReferenceError
 함수 호출시에 그룹 연산자() 내에 함수가 있다면 ()안에 있는 피연산자는 값으로 표현될 수 있는 표현식이어야 하는데 따라서 표현식이 아닌 문인 함수선언문으로 사용할 수 없고 리터럴 표현식으로 해석된다. 이때 함수 리터럴 표현식에서는 함수 이름을 외부에서 참조할 수 없다고 했으므로
 일반적인 경우처럼 함수를 호출 할 수 없다. 함수를 가리키는 식별자가 없기 때문이다.

 함수 선언문으로 정의된 함수 또한 함수이름으로 외부에서 호출할 수 없기는 마찬가지. 하지만 자바스크립트 엔진이 암묵적으로 함수 선언문을 해석시 식별자가 따로 없으면 함수이름과 동일한 식별자를 자동으로 생성하고 거기에 함수 객체의 참조값을 할당한다.

 따라서 우리는 함수는 함수 이름으로 함수를 호출하는 것이 아니라 함수의 식별자로 호출하는 것이다.

 함수 표현식

 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다.
 값의 성질을 갖는 객체를 일급 객체라 하는데 따라서 자바스크립트 함수는 1급 객체이다.
 함수는 일급 객체임으로(값을 가질 수 있음) 변수에 할당 할 수 있는데 이러한 함수 정의 방식을 함수 표현식이라 한다.

함수 표현식은 일반적으로 익명함수를 사용하는데 이름을 만들어봤자 어차피 호출시에 식별자 이름을 사용해 호출 하는 수 밖에 없다. 함수 이름은 함수 내부에서 밖에 사용을 못하기 때문이다.

함수 선언문은 표현식이 아닌 문이고, 함수 표현식은 표현식인 문이다.

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 할 수 있다.(함수 호이스팅 발생)
함수 표현식으로 정의한 함수는 표현식 이전에 호출 할 수 없다. (변수 호이스팅이 발생.)
이유는 함수 선언문으로 정의한 함수와 표현식으로 정의한 함수의 생성 시점이 다르기 때문인데 모든 선언문은 자바스크립트 엔진에 의해 코드가 순차적으로 실행되는 런타임 이전에 실행된다. 즉 함수 선언문은 코드가 실행되기 이전에 함수 객체를 생성하여 호출코드 밑에 함수가 선언 되어 있더라도 참조가 가능하다. 이것을 함수 호이스팅이라 한다.

변수 호이스팅과 함수 호이스팅의 차이점은? 함수 호이스팅은 함수 객체로 초기화함, 변수 호이스팅은 undefined 값으로 초기화.
function 생성자 함수

생성자 함수는 객체를 생성하는 함수를 말한다. 생성자 함수는 함수선언문이나 함수 표현식으로 생성한 함수가 동일하게 동작하지 않는다.

함수는 매개변수와 인수의 개수가 일치하지 않아도 작동한다. 초과된 인수는 버려지는 것이 아니라 아규먼트 객체의 프로퍼티로 보관된다.

